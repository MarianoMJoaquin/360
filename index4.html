<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Visor 360° Ajustado y Fluido</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .viewer-container {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
      background-color: #f3f4f6;
    }

    .viewer {
      width: 600px;
      height: 316px;
      overflow: hidden;
      cursor: grab;
      background-size: 3000% 100%;
      background-position: 0 0;
      transition: transform 0.1s ease;
    }

    
  </style>
</head>
<body class="bg-gray-100 flex flex-col items-center justify-center min-h-screen">
  
  <div class="viewer-container bg-red-300">
    <div class="viewer bg-white" id="viewer"></div>
  </div>

  <script>
    const totalFrames = 30;
    let currentFrame = 0;
    let isDragging = false;
    let startX = 0;
    const frameWidthPercentage = 100 / totalFrames;
    const viewer = document.getElementById('viewer');

    function updateFrame(diffX) {
      // Calcular los fotogramas a avanzar basado en la dirección
      if (diffX > 20) {
        // Avanzar hacia la derecha
        currentFrame = (currentFrame + 1) % totalFrames;
        startX += 20; // Ajuste de inicio para evitar acumulación
      } else if (diffX < -20) {
        // Avanzar hacia la izquierda
        currentFrame = (currentFrame - 1 + totalFrames) % totalFrames;
        startX -= 20;
      }

      // Actualizar posición de fondo para mostrar el fotograma actual
      const offsetX = currentFrame * frameWidthPercentage;
      viewer.style.backgroundPosition = `${offsetX}% 0`;
    }

    function animate() {
      if (isDragging) {
        requestAnimationFrame(animate);
      }
    }

    viewer.addEventListener('mousedown', (event) => {
      isDragging = true;
      startX = event.pageX;
      viewer.style.cursor = "grabbing";
      requestAnimationFrame(animate);
    });

    viewer.addEventListener('mouseup', () => {
      isDragging = false;
      viewer.style.cursor = "grab";
    });

    viewer.addEventListener('mouseleave', () => {
      isDragging = false;
      viewer.style.cursor = "grab";
    });

    viewer.addEventListener('mousemove', (event) => {
      if (isDragging) {
        const diffX = event.pageX - startX;
        updateFrame(diffX);
      }
    });

    // --- Soporte para dispositivos táctiles ---
    viewer.addEventListener('touchstart', (event) => {
      isDragging = true;
      startX = event.touches[0].pageX;
      requestAnimationFrame(animate);
    });

    viewer.addEventListener('touchend', () => {
      isDragging = false;
    });

    viewer.addEventListener('touchmove', (event) => {
      if (isDragging) {
        const diffX = event.touches[0].pageX - startX;
        updateFrame(diffX);
      }
    });

    // Carga diferida del sprite solo cuando esté visible
    const spriteObserver = new IntersectionObserver(entries => {
      if (entries[0].isIntersecting) {
        viewer.style.backgroundImage = "url('corolla-images.png')";
        spriteObserver.disconnect();
      }
    }, { threshold: 0.1 });
    spriteObserver.observe(viewer);
  </script>

</body>
</html>
